package com.tabulify.gen;

import com.tabulify.gen.generator.CollectionGenerator;
import com.tabulify.gen.generator.SequenceGenerator;
import com.tabulify.model.ColumnDef;
import com.tabulify.model.PrimaryKeyDef;
import com.tabulify.model.UniqueKeyDef;
import net.bytle.exception.NoValueException;
import net.bytle.exception.NoVariableException;
import net.bytle.type.Casts;

import java.util.List;
import java.util.stream.Collectors;

public class GenDataPathUtility {


  private final GenDataPath genDataPath;

  public GenDataPathUtility(GenDataPath genDataPath) {
    this.genDataPath = genDataPath;
  }

  /**
   * @return The maximum size of data that can be generated by the collection of generators
   */
  private Long getMaxSizeFromGenerators() {

    buildMissingGenerators();

    return CollectionGenerator.createDag()
      .addRelations(
        this.genDataPath
          .getOrCreateRelationDef()
          .getColumnDefs()
          .stream()
          .map(c -> c.getOrCreateGenerator(c.getClazz()))
          .collect(Collectors.toList())
      ).getCreateOrdered()
      .stream()
      .mapToLong(CollectionGenerator::getCount)
      .min()
      .orElse(Long.MAX_VALUE);
  }


  /**
   * This function will build the generator for the columns without one
   */
  public void buildMissingGenerators() {

    genDataPath
      .getOrCreateRelationDef()
      .getColumnDefs()
      .stream()
      .filter(c -> c.getGenerator() == null)
      .forEach(this::buildMissingGeneratorForColumn);

  }

  /**
   * Function that is used to build a data generator if missing for the column
   * *
   * This is also a function that can create several generator for several columns (for instance, if the column is part
   * of a unique key, one generator will be created with all columns at once).
   */
  private void buildMissingGeneratorForColumn(GenColumnDef columnDef) {

    CollectionGenerator<?> generator = columnDef.getGenerator();
    if (generator != null) {
      return;
    }

    // If primary key
    PrimaryKeyDef primaryKey = genDataPath
      .getOrCreateRelationDef()
      .getPrimaryKey();
    if (primaryKey != null) {
      List<ColumnDef> primaryColumns = primaryKey.getColumns();
      if (primaryColumns.contains(columnDef)) {

        if (primaryColumns.size() == 1) {

          GenColumnDef primaryCol = (GenColumnDef) primaryColumns.get(0);
          primaryCol.addSequenceGenerator(primaryCol.getClazz());

        } else {

          List<GenColumnDef> genPrimaryColumns =
            primaryColumns
              .stream()
              .map(DataGens::castToGenColumnDef)
              .collect(Collectors.toList());
          SequenceGenerator.createOdometer(genPrimaryColumns);

        }

        return;

      }

    }

    // Not yet returned
    List<UniqueKeyDef> uniqueKeys = genDataPath.getOrCreateRelationDef().getUniqueKeys().stream()
      .filter(uk -> uk.getColumns().contains(columnDef))
      .collect(Collectors.toList());

    if (uniqueKeys.size() > 0) {

      uniqueKeys.forEach(uniqueKeyDef -> {
        List<GenColumnDef> ukCols =
          uniqueKeyDef
            .getColumns()
            .stream()
            .map(DataGens::castToGenColumnDef)
            .collect(Collectors.toList());

        if (ukCols.size() == 0) {
          throw new IllegalStateException("The unique key constraint (" + uniqueKeyDef + ") have no columns, we can't therefore add a unique key generator. Delete the constraint or add columns to it.");
        } else {
          SequenceGenerator.createOdometer(ukCols);
        }

      });

      return;

    }

    // Else
    columnDef.addRandomGenerator(columnDef.getClazz());


  }

  /**
   * This function will build the generator for the primary columns without one
   */
  public void buildMissingPrimaryKeyGenerators() {

    PrimaryKeyDef primaryKey = genDataPath.getOrCreateRelationDef().getPrimaryKey();
    if (primaryKey != null) {
      primaryKey.getColumns().stream()
        .map(c -> (GenColumnDef) c)
        .filter(c -> c.getOrCreateGenerator(c.getClazz()) == null)
        .forEach(this::buildMissingGeneratorForColumn);
    }

  }

  /**
   * @return the max size of rows generated is set or null
   */
  public Long getMaxRecordCount() {
    try {
      return Casts.castSafe(genDataPath.getVariable(GenDataPath.MAX_RECORD_COUNT_PROPERTY_KEY).getValueOrDefault(), Long.class);
    } catch (NoVariableException | NoValueException e) {
      return null;
    }
  }

  /**
   * @return The count of data that will be generated
   */
  public Long getCount() {

    Long maxNumberOfRowToInsert = getMaxSizeFromGenerators();

    // Max size capping ?
    Long maxSize = this.getMaxRecordCount();
    if (maxSize != null && maxNumberOfRowToInsert > maxSize) {
      return maxSize;
    } else {
      return maxNumberOfRowToInsert;
    }

  }


  /**
   * @param maxRecordCount Maximum number of rows created
   * @return the object for chaining
   */
  public GenDataPathUtility setMaxRecordCount(Long maxRecordCount) {
    // Just to be able to have this function in a fluent code with a null value
    if (maxRecordCount != null) {
      genDataPath.getOrCreateRelationDef().getDataPath().addVariable(GenDataPath.MAX_RECORD_COUNT_PROPERTY_KEY, maxRecordCount);
    }
    return this;
  }


}
