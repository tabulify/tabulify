package com.tabulify.gen;

import com.tabulify.conf.Attribute;
import com.tabulify.conf.Origin;
import com.tabulify.gen.fs.GenManifestDataPath;
import com.tabulify.gen.generator.CollectionGenerator;
import com.tabulify.gen.generator.SequenceGenerator;
import com.tabulify.model.ColumnDef;
import com.tabulify.model.PrimaryKeyDef;
import com.tabulify.model.UniqueKeyDef;
import com.tabulify.spi.DataPath;
import net.bytle.exception.InternalException;
import net.bytle.exception.MissingSwitchBranch;
import net.bytle.exception.NoVariableException;
import net.bytle.type.Casts;

import java.util.List;
import java.util.stream.Collectors;

/**
 * A utility that contains method used in {@link GenManifestDataPath}
 * and {@link com.tabulify.gen.memory.GenMemDataPath}
 */
public class GenDataPathUtility {


  private final GenDataPath genDataPath;
  private Long sizeNotCapped = null;


  public GenDataPathUtility(GenDataPath genDataPath) {
    this.genDataPath = genDataPath;
  }

  /**
   * @return The maximum count of data that can be generated by the collection of generators
   */
  public Long getMaxCountFromGenerators() {

    /**
     * Cache
     */
    if (this.sizeNotCapped != null) {
      return this.sizeNotCapped;
    }

    buildMissingGenerators();
    this.sizeNotCapped = CollectionGenerator.createDag()
      .addRelations(
        this.genDataPath
          .getOrCreateRelationDef()
          .getColumnDefs()
          .stream()
          .map(GenColumnDef::getOrCreateGenerator)
          .collect(Collectors.toList())
      ).getCreateOrdered()
      .stream()
      .mapToLong(gene -> {
        long count = gene.getCount();
        if (count == 1L) {
          throw new InternalException("Generation count is 1");
        }
        return count;
      })
      .min()
      .orElse(Long.MAX_VALUE);
    return this.sizeNotCapped;
  }


  /**
   * This function will build the generator for the columns without one
   */
  public void buildMissingGenerators() {

    genDataPath
      .getOrCreateRelationDef()
      .getColumnDefs()
      .stream()
      .filter(c -> c.getOrCreateGenerator() == null)
      .forEach(this::buildMissingGeneratorForColumn);

  }

  /**
   * Function that is used to build a data generator if missing for the column
   * *
   * This is also a function that can create several generator for several columns (for instance, if the column is part
   * of a unique key, one generator will be created with all columns at once).
   */
  private void buildMissingGeneratorForColumn(GenColumnDef<?> columnDef) {

    CollectionGenerator<?> generator = columnDef.getGenerator();
    if (generator != null) {
      return;
    }

    // If primary key
    PrimaryKeyDef primaryKey = genDataPath
      .getOrCreateRelationDef()
      .getPrimaryKey();
    if (primaryKey != null) {
      List<ColumnDef<?>> primaryColumns = primaryKey.getColumns();
      if (primaryColumns.contains(columnDef)) {

        if (primaryColumns.size() == 1) {

          GenColumnDef<?> primaryCol = (GenColumnDef<?>) primaryColumns.get(0);
          primaryCol.addSequenceGenerator();

        } else {

          List<GenColumnDef<?>> genPrimaryColumns =
            primaryColumns
              .stream()
              .map(DataGens::castToGenColumnDef)
              .collect(Collectors.toList());
          SequenceGenerator.createOdometer(genPrimaryColumns);

        }

        return;

      }

    }

    // Not yet returned
    List<UniqueKeyDef> uniqueKeys = genDataPath.getOrCreateRelationDef().getUniqueKeys().stream()
      .filter(uk -> uk.getColumns().contains(columnDef))
      .collect(Collectors.toList());

    if (!uniqueKeys.isEmpty()) {

      uniqueKeys.forEach(uniqueKeyDef -> {
        List<GenColumnDef<?>> ukCols =
          uniqueKeyDef
            .getColumns()
            .stream()
            .map(DataGens::castToGenColumnDef)
            .collect(Collectors.toList());

        if (ukCols.isEmpty()) {
          throw new IllegalStateException("The unique key constraint (" + uniqueKeyDef + ") have no columns, we can't therefore add a unique key generator. Delete the constraint or add columns to it.");
        } else {
          SequenceGenerator.createOdometer(ukCols);
        }

      });

      return;

    }

    // Else
    columnDef.addRandomGenerator();


  }

  /**
   * This function will build the generator for the primary columns without one
   */
  public void buildMissingPrimaryKeyGenerators() {

    PrimaryKeyDef primaryKey = genDataPath.getOrCreateRelationDef().getPrimaryKey();
    if (primaryKey != null) {
      primaryKey.getColumns().stream()
        .map(c -> (GenColumnDef<?>) c)
        .filter(c -> c.getOrCreateGenerator() == null)
        .forEach(this::buildMissingGeneratorForColumn);
    }

  }

  /**
   * @return the max size of rows generated is set or null
   */
  public Long getMaxRecordCount() {
    try {
      return Casts.castSafe(genDataPath.getAttribute(GenDataPathAttribute.MAX_RECORD_COUNT).getValueOrDefault(), Long.class);
    } catch (NoVariableException e) {
      return null;
    }
  }

  /**
   * @return The count of data that will be generated
   */
  public Long getCount() {

    Long maxNumberOfRowToInsert = getMaxCountFromGenerators();

    // Max size capping ?
    Long maxSize = this.getMaxRecordCount();
    if (maxSize != null && maxNumberOfRowToInsert > maxSize) {
      return maxSize;
    }
    return maxNumberOfRowToInsert;

  }


  /**
   * @param maxRecordCount Maximum number of rows created
   * @return the object for chaining
   */
  public GenDataPathUtility setMaxRecordCount(Long maxRecordCount) {
    // Just to be able to have this function in a fluent code with a null value
    if (maxRecordCount != null) {
      /**
       * We set the value in the attributes because
       * a manifest gen file is copied to a memory gen
       */
      DataPath dataPath = genDataPath.getOrCreateRelationDef().getDataPath();
      dataPath.getAttributeSafe(GenDataPathAttribute.MAX_RECORD_COUNT)
        .setPlainValue(maxRecordCount);
    }
    return this;
  }


  public void initAttributes() {
    for (GenDataPathAttribute dataGenAttribute : GenDataPathAttribute.class.getEnumConstants()) {
      switch (dataGenAttribute) {
        case SIZE_NOT_CAPPED:
          genDataPath.addAttribute(
            Attribute.create(dataGenAttribute, Origin.DEFAULT)
              .setValueProvider(genDataPath::getSizeNotCapped)
          );
          break;
        case SIZE:
          genDataPath.addAttribute(
            Attribute.create(dataGenAttribute, Origin.DEFAULT)
              .setValueProvider(genDataPath::getSize)
          );
          break;
        case STREAM_RECORD_COUNT:
        case MAX_RECORD_COUNT:
          genDataPath.addAttribute(
            Attribute.create(dataGenAttribute, Origin.DEFAULT)
              .setPlainValue(dataGenAttribute.getDefaultValue())
          );
          break;
        default:
          throw new MissingSwitchBranch("dataGenAttribute", dataGenAttribute);
      }
    }

  }

  public Long getStreamRecordCount() {
    try {
      return Casts.castSafe(genDataPath.getAttribute(GenDataPathAttribute.STREAM_RECORD_COUNT).getValueOrDefault(), Long.class);
    } catch (NoVariableException e) {
      return null;
    }
  }

  public GenDataPathUtility setStreamRecordCount(Long streamRecordCount) {
    // Just to be able to have this function in a fluent code with a null value
    if (streamRecordCount != null) {
      /**
       * We set the value in the attributes because
       * a manifest gen file is copied to a memory gen
       */
      DataPath dataPath = genDataPath.getOrCreateRelationDef().getDataPath();
      dataPath.getAttributeSafe(GenDataPathAttribute.STREAM_RECORD_COUNT)
        .setPlainValue(streamRecordCount);
    }
    return this;
  }


}
