package net.bytle.vertx;

import io.vertx.core.Future;
import io.vertx.core.Handler;
import io.vertx.core.Vertx;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.auth.User;
import io.vertx.ext.auth.authorization.RoleBasedAuthorization;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.handler.BodyHandler;
import io.vertx.ext.web.openapi.RouterBuilder;
import io.vertx.ext.web.openapi.RouterBuilderOptions;
import io.vertx.ext.web.openapi.impl.OpenAPI3RouterBuilderImpl;
import net.bytle.exception.InternalException;
import net.bytle.exception.NotFoundException;

import java.net.URI;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashSet;
import java.util.Set;

/**
 * An entry point for all OpenApi related code
 */
public class OpenApiService extends TowerService {


  public static final String OPENAPI_YAML_PATH = "/openapi.yaml";
  /**
   * The first directory in the resource main directory
   * for the location of the spec file
   */
  private static final String OPEN_API_RESOURCES_PREFIX = "openapi-spec-file";

  /**
   * The key in the {@link io.vertx.ext.web.RoutingContext#get(String)} to get access
   * to the operations properties on the routing context
   */
  private static final String CONTEXT_OPERATION_MODEL_KEY = "openApiOperationModel";
  private final URI specFile;
  private final OpenApiDoc openApiDoc;
  private final String relativeOpenApiResourceSpecFile;
  private final OpenApiInstance openApiInstance;

  public OpenApiService(OpenApiInstance openApiInstance) {

    super(openApiInstance.getApp().getHttpServer().getServer());
    this.openApiInstance = openApiInstance;

    TowerApp towerApp = openApiInstance.getApp();

    /**
     * Note that the openapi.yaml files may be generated by the OpenApi Generator
     * The source files are known as combo-xxxx-openapi.yaml
     */
    String tempRelativeOpenApiResourceSpecFile = OPEN_API_RESOURCES_PREFIX + "/" + towerApp.getApexDomain().getFileSystemPathName().toLowerCase() + "/" + towerApp.getAppName().toLowerCase() + OPENAPI_YAML_PATH;

    /**
     * The run in dev is not via a Jar archive
     */
    String specFilePathInDev = "src/main/resources/" + tempRelativeOpenApiResourceSpecFile;
    Path mainSpecFile = Paths.get(specFilePathInDev);
    if (Files.exists(mainSpecFile)) {
      tempRelativeOpenApiResourceSpecFile = specFilePathInDev;
    }

    this.relativeOpenApiResourceSpecFile = tempRelativeOpenApiResourceSpecFile;
    specFile = URI.create(relativeOpenApiResourceSpecFile);

    this.openApiDoc = new OpenApiDoc(this);

  }

  /**
   * @param routingContext - the routing context
   * @return the Json Object of the operation path in the openapi spec
   */
  public JsonObject getOperationModel(RoutingContext routingContext) {
    return routingContext.get(CONTEXT_OPERATION_MODEL_KEY);
  }


  public Set<String> getScopes(RoutingContext routingContext) {
    JsonObject operationJsonOpenApiData = getOperationModel(routingContext);
    String operationId = operationJsonOpenApiData.getString("operationId");
    Object securities = operationJsonOpenApiData.getMap().get("security");
    if (securities == null) {
      throw new InternalException("The OpenApi security was not found for the operation id (" + operationId + ")");
    }
    Set<String> scopes = new HashSet<>();
    if (!(securities instanceof JsonArray)) {
      throw new InternalException("The OpenApi security scopes should be in a array/list format for the operation id (" + operationId + ")");
    }
    JsonArray arraySecurities = (JsonArray) securities;
    for (int i = 0; i < arraySecurities.size(); i++) {
      JsonObject security = arraySecurities.getJsonObject(i);
      for (String securityKey : security.getMap().keySet()) {
        JsonArray securityScopes = security.getJsonArray(securityKey);
        for (int j = 0; j < securityScopes.size(); j++) {
          scopes.add(securityScopes.getString(j));
        }
      }
    }
    return scopes;

  }

  public OpenApiInstance getOpenApiInstance() {
    return this.openApiInstance;
  }

  /**
   * @return the relative path in the resource directory to the open api spec file
   */
  public String getRelativeOpenApiSpecFileResourcesPath() {
    return this.relativeOpenApiResourceSpecFile;
  }


  public Handler<RoutingContext> authorizationCheckHandler() {

    OpenApiService openApi = this;
    return routingContext -> {
      Set<String> scopes = openApi.getScopes(routingContext);

      for (String scope : scopes) {
        User user = routingContext.user();
        if (!RoleBasedAuthorization.create(scope).match(user)) {
          TowerFailureException.builder()
            .setType(TowerFailureTypeEnum.NOT_AUTHORIZED_403)
            .setMessage("The scope (" + scope + ") is not granted to the authenticated user (" + user.subject() + ")")
            .setMimeToJson()
            .buildWithContextFailingTerminal(routingContext);
          return;
        }
      }
      routingContext.next();

    };

  }

  @Override
  public Future<Void> mount() {

    Router rootRouter = this.openApiInstance.getApp().getHttpServer().getRouter();

    /**
     * Add the serving of the doc
     */
    this.openApiDoc.addHandler(rootRouter);

    /**
     * Note: a router should not be shared between verticles.
     * https://vertx.io/docs/vertx-web-openapi/java/
     */
    String specFileString = specFile.toString();
    Vertx vertx = this.openApiInstance.getApp().getHttpServer().getServer().getVertx();
    return RouterBuilder.create(vertx, specFileString)
      .recover(err -> {
        InternalError error = new InternalError("Unable to build the openapi memory model for the spec file (" + specFileString + "). Check the inputScope to see where the error is.", err);
        return Future.failedFuture(TowerFailureException.builder()
          .setCauseException(error)
          .build()
        );
      })
      .compose(routerBuilder -> {

        /**
         * The order of the build of the router is important:
         * - bodyHandler, first
         * - securityHandler, second
         * - then operation mount (platform), third
         */

        /**
         * Custom Body Handler
         * (Open Api adds a default body handler
         * if there is no global handler (ie {@link RouterBuilder#rootHandler(Handler)}) defined
         * We add therefore ours to disable this behaviour
         * See {@link OpenAPI3RouterBuilderImpl#createRouter()}
         */
        try {
          BodyHandler bodyHandler = this.openApiInstance.getApp().getHttpServer().getBodyHandler();
          routerBuilder.rootHandler(bodyHandler);
        } catch (NotFoundException e) {
          // default body handler of openapi is used
        }

        boolean requireSecurityHandlers = this.openApiInstance.requireSecurityHandlers();
        if (requireSecurityHandlers) {
          this.openApiInstance
            .openApiAddSecurityHandlers(routerBuilder, this);
        }

        this.openApiInstance.openApiMount(routerBuilder);

        routerBuilder.setOptions(
          new RouterBuilderOptions()
            .setRequireSecurityHandlers(requireSecurityHandlers)
            .setOperationModelKey(CONTEXT_OPERATION_MODEL_KEY)
            .setMountNotImplementedHandler(false)
        );

        /**
         * Mount all routes of the openapi specification
         * <p>
         * ***At the end***
         * To have the other directive taking place
         * before (otherwise, for instance, there would be no security handler
         * taking place such as the CSRF token)
         */

        Router openApiRouter;
        try {
          openApiRouter = routerBuilder
            .createRouter();
        } catch (Exception e) {
          return Future.failedFuture(
            TowerFailureException
              .builder()
              .setMessage("Error while building the openapi router for the app (" + this.openApiInstance.getApp() + ")")
              .setCauseException(e)
              .build()
          );
        }
        /**
         * Sub-router tip from https://vertx.io/docs/vertx-web-openapi/java/#_generate_the_router
         */
        String localhostAbsolutePathMount = this.openApiInstance.getApp().getPathMount();
        if (!localhostAbsolutePathMount.isEmpty() && !localhostAbsolutePathMount.equals("/")) {
          String apiAbsolutePath = localhostAbsolutePathMount + "/*";
          rootRouter.route(apiAbsolutePath)
            .subRouter(openApiRouter);
        } else {
          rootRouter.route().subRouter(openApiRouter);
        }

        return super.mount();
      });

  }
}
