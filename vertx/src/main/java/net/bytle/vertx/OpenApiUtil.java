package net.bytle.vertx;

import io.vertx.core.Future;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.openapi.RouterBuilder;
import io.vertx.ext.web.openapi.RouterBuilderOptions;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.net.URI;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;


public class OpenApiUtil {

  private static final Logger LOGGER = LogManager.getLogger(OpenApiUtil.class);

  /**
   * The key in the {@link io.vertx.ext.web.RoutingContext#get(String)} to get access
   * to the operations
   */
  private static final String CONTEXT_OPERATION_MODEL_KEY = "comboOpenApiOperationModel";
  private URI specFile;
  private TowerApp towerApp;

  public static OpenApiUtil.config config(TowerApp app) {
    return new OpenApiUtil.config(app);
  }

  @SuppressWarnings("unused")
  public JsonObject getOperationModel(RoutingContext routingContext) {
    return routingContext.get(CONTEXT_OPERATION_MODEL_KEY);
  }

  public Future<Void> mountOpenApi(Router rootRouter) {

    /**
     * Add the serving of the doc
     */
    OpenApiDoc.addHandler(rootRouter, towerApp);

    /**
     * Note: a router should not be shared between verticles.
     * https://vertx.io/docs/vertx-web-openapi/java/
     */
    String specFileString = specFile.toString();
    return RouterBuilder.create(towerApp.getApexDomain().getHttpServer().getServer().getVertx(), specFileString)
      .onFailure(err-> LOGGER.error("Unable to build the openapi memory model for the spec file ("+specFileString+"). Check the inputScope to see where the error is.", err))
      .compose(routerBuilder -> {

        towerApp
          .openApiMount(routerBuilder)
          .openApiBindSecurityScheme(routerBuilder, this.towerApp.getApexDomain().getHttpServer().getServer().getConfigAccessor());

        routerBuilder.setOptions(new RouterBuilderOptions()
          .setRequireSecurityHandlers(true)
          .setOperationModelKey(CONTEXT_OPERATION_MODEL_KEY)
        );

        /**
         * Mount all routes of the openapi specification
         * <p>
         * ***At the end***
         * To have the other directive taking place
         * before (otherwise, for instance, there would be no security handler
         * taking place such as the CSRF token)
         */

        Router openApiRouter;
        try {
          openApiRouter = routerBuilder
            .createRouter();
        } catch (Exception e) {
          RuntimeException error = new RuntimeException("Error while building the router for the app ("+towerApp+")", e);
          return Future.failedFuture(error);
        }
        /**
         * Sub-router tip from https://vertx.io/docs/vertx-web-openapi/java/#_generate_the_router
         */
        String apiAbsolutePath = towerApp.getAbsoluteLocalPathWithDomain() + "/*";
        rootRouter.route(apiAbsolutePath)
          .subRouter(openApiRouter);

        return Future.succeededFuture();

      });
  }


  public static class config {
    private final TowerApp towerApp;

    public config(TowerApp app) {

      this.towerApp = app;
    }

    public OpenApiUtil build() {

      /**
       * Note that the openapi.yaml files may be generated by the OpenApi Generator
       * The source files are known as combo-xxxx-openapi.yaml
       */
      String resourceSpecFile = towerApp.getRelativeSpecFileResourcesPath();

      /**
       * The run in dev is not via a Jar archive
       */
      String specFilePathInDev = "src/main/resources/" + resourceSpecFile;
      Path mainSpecFile = Paths.get(specFilePathInDev);
      if(Files.exists(mainSpecFile)){
        resourceSpecFile = specFilePathInDev;
      }

      OpenApiUtil comboOpenBuilder = new OpenApiUtil();
      comboOpenBuilder.specFile = URI.create(resourceSpecFile);
      comboOpenBuilder.towerApp = towerApp;
      return comboOpenBuilder;


    }
  }


}
