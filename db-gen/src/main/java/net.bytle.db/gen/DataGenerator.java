package net.bytle.db.gen;

import net.bytle.db.gen.generator.CollectionGenerator;
import net.bytle.db.gen.generator.DistributionCollectionGenerator;
import net.bytle.db.gen.generator.UniqueDataCollectionGenerator;
import net.bytle.db.model.ColumnDef;
import net.bytle.db.model.PrimaryKeyDef;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class DataGenerator {

  private final GenDataPath genDataPath;
  private final List<GenColumnDef> primaryColumns;
  private final List<GenColumnDef> allUniqueKeyColumns;

  public DataGenerator(GenDataPath genDataPath) {
    this.genDataPath = genDataPath;

    // Convenience shortcut
    PrimaryKeyDef primaryKey = genDataPath
      .getDataDef()
      .getPrimaryKey();
    if (primaryKey != null) {
      primaryColumns = primaryKey
        .getColumns().stream()
        .map(DataGens::castToGenColumnDef)
        .collect(Collectors.toList());
    } else {
      primaryColumns = new ArrayList<>();
    }

    allUniqueKeyColumns = genDataPath
      .getDataDef()
      .getUniqueKeys().stream()
      .flatMap(uk -> uk.getColumns().stream())
      .map(DataGens::castToGenColumnDef)
      .collect(Collectors.toList());


    // First pass to create a default generator if they are not specified
    for (GenColumnDef columnDef : genDataPath.getDataDef().getColumnDefs()) {
        buildDefaultDataGeneratorForColumn(columnDef);
    }

  }

  public static DataGenerator of(GenDataPath genDataPath) {
    return new DataGenerator(genDataPath);
  }

  /**
   * The build has a recursive shape because of the derived data generator that depends on another
   * We used this map to track what was build
   */
  private Map<ColumnDef, CollectionGenerator> dataGenerators = new HashMap<>();

  /**
   * Function that is used to build the data generator for the column
   * It had the generators to the map of Generators.
   * <p>
   * This is a reflective function who can call itself when the generator depends on another column generator.
   * This is also a function that can create several generator for several columns (for instance, if the column is part
   * of an unique key, one generator will be created with all columns at once).
   */
  public <T> void buildDefaultDataGeneratorForColumn(GenColumnDef<T> columnDef) {

    // Recursive call may create a generator
    CollectionGenerator generator = dataGenerators.get(columnDef);
    if (generator == null) {

      CollectionGenerator dataGenerator = columnDef.getGenerator();
      if (dataGenerator != null) {
        dataGenerators.put(columnDef, dataGenerator);
        return;
      }

    }


    // A data generator was not yet fund, we will find one with the column constraint
    if (this.primaryColumns.contains(columnDef)) {

      final List<ColumnDef> primaryColumnsForColumnDefTable = primaryColumns.stream().filter(c -> c.getDataDef().equals(columnDef.getDataDef())).collect(Collectors.toList());
      UniqueDataCollectionGenerator uniqueDataGenerator = new UniqueDataCollectionGenerator(primaryColumnsForColumnDefTable);
      for (ColumnDef pkColumns : primaryColumnsForColumnDefTable) {
        dataGenerators.put(pkColumns, uniqueDataGenerator);
      }
      return;

      // TODO
      //    } else if (columnForeignKeyMap.keySet().contains(columnDef)) {
      //
      //      final FkDataGenerator dataGenerator = new FkDataGenerator(columnForeignKeyMap.get(columnDef));
      //      dataGenerators.put(columnDef, dataGenerator);
      //      return;

    } else if (allUniqueKeyColumns.contains(columnDef)) {

      List<ColumnDef> uniqueKeyColumns = genDataPath.getDataDef().getUniqueKeys().stream()
        .filter(uk -> uk.getColumns().contains(columnDef))
        .flatMap(uk -> uk.getColumns().stream())
        .collect(Collectors.toList());

      UniqueDataCollectionGenerator uniqueDataGenerator = new UniqueDataCollectionGenerator(uniqueKeyColumns);
      for (ColumnDef uniqueKeyColumn : allUniqueKeyColumns) {
        dataGenerators.put(uniqueKeyColumn, uniqueDataGenerator);
      }
      return;

    }

    // Else
    dataGenerators.put(columnDef, new DistributionCollectionGenerator<>(columnDef));


  }

  public <T> CollectionGenerator<T> getCollectionGenerator(ColumnDef<T> columnDef) {
    return dataGenerators.get(columnDef);
  }

  public int getDataGeneratorsSize() {
    return dataGenerators.size();
  }

  /**
   * @return The maximum size of data that will be generated
   */
  public long getMaxSize() {

    Long maxNumberOfRowToInsert = getMaxGeneratedSize();

    // Max size capping ?
    Long maxSize = genDataPath.getDataDef().getMaxSize();
    if (maxSize != null && maxNumberOfRowToInsert > maxSize) {
      return maxSize;
    } else {
      return maxNumberOfRowToInsert;
    }

  }

  /**
   * @return The maximum size of data that can be generated by the collection generators
   */
  private Long getMaxGeneratedSize() {

    Long maxNumberOfRowToInsert = 0L;
    for (CollectionGenerator dataGenerator : dataGenerators.values()) {
      final Long maxGeneratedValues = dataGenerator.getMaxGeneratedValues();
      if (maxNumberOfRowToInsert == 0) {
        maxNumberOfRowToInsert = maxGeneratedValues;
      } else {
        if (maxNumberOfRowToInsert > maxGeneratedValues) {
          maxNumberOfRowToInsert = maxGeneratedValues;
        }
      }
    }
    return maxNumberOfRowToInsert;
  }


}
