#!/bin/bash
# Control the apps


CLI_NAME=$(basename "$0") # Name of the cli

function finish() {
  printf "\nScript terminated\n"
}
trap finish EXIT

# Send the message to the log file and the stdout
#
# The log file can be given via the first arg $2
# Default to the variable ${LOG_FILE}
function echo_log() {

  LOCAL_LOG_FILE_PATH=${LOG_FILE}
  if ! [ -z ${2+x} ]; then
    LOCAL_LOG_FILE_PATH=$2
  fi
  MESSAGE=$1
  echo -e "$MESSAGE" 2>&1 | tee -a "${LOCAL_LOG_FILE_PATH}"

}

# Print the error message $1
function echo_err() {
  RED='\033[0;31m'
  NC='\033[0m' # No Color
  #(>&2 echo -e "${RED}$1${NC}")
  echo_log "${RED}$1${NC}"
}

function getStatData() {

  if [ -z "$1" ]; then
    echo_err 'The Pid should be given as first argument for stat data'
    exit 1
  fi
  pid=$1
  # Average
  frequency=1 # in sec
  period=3    # in sec
  averageLine=$(pidstat -p "$pid" -l $frequency $period | grep Average)
  averageCpu=$(echo "$averageLine" | awk '{print $7}' | xargs printf "%.0f")
  averageMemory=$(echo "$averageLine" | awk '{print $6}' | xargs printf "%.0f")
  echo "$averageCpu $averageMemory"
}

function getOsData() {
  # CPU_Util = (user+system+nice+softirq+steal)/ (user+system+nice+softirq+steal+idle+iowait)
  # see also mpstat
  totalCpu=$(top -bn1 | grep "Cpu(s)" | sed "s/.*, *\([0-9.]*\)%* id.*/\1/" | awk '{print 100 - $1}' | xargs printf "%.0f")
  # Memory used/total
  totalMemory=$(free -m | awk 'NR==2{print $3/$2*100}' | xargs printf "%.0f")
  echo "$totalCpu" "$totalMemory"
}

function getOptionValue() {
  # Options
  # shellcheck disable=SC2034
  IFS='=' read -r key value <<<"${1:2}"
  if [ "$value" == "" ]; then
    value=true
  fi
  echo "$value"
}

function instantOs() {

  read -r totalCpu totalMemory <<<"$(getOsData)"
  echo "Os report:"
  echo "  * Total Cpu: ${totalCpu}%"
  echo "  * Total Memory Usage: $totalMemory%"

}

function print_usage() {

  echo ""
  echo "Usage of the cli ${CLI_NAME}"
  echo ""
  echo "   ${CLI_NAME} command app [--option[=value] ...]"
  echo ""
  echo "where command is one of:"
  echo "     * ls         - list the apps"
  echo "     * monitoring - show the app log in tail fashion"
  echo "     * log        - browse the app log in reverse order"
  echo "     * journal    - access to journalctl to pass other args"
  echo "     * start      - start the app"
  echo "     * stop       - stop the app"
  echo "     * reload     - reload the app"
  echo "     * restart    - restart the app"
  echo ""

}

declare -a OPTIONS
# Parsing
for arg in "$@"; do
  case "$arg" in
  --*)
    OPTIONS+=("$arg")
    shift
    ;;
  *)
    # Command
    if [ -z "$COMMAND" ]; then
      COMMAND=$1
      echo "Command ($COMMAND) found"
    elif [ -z "$APP" ]; then
      APP=$1
      echo "App ($APP) found"
    fi
    shift
    ;;
  esac
done

if [ -z "$COMMAND" ]; then
  COMMAND='help'
  echo "No command was given, $COMMAND chosen."
fi

echo
echo "${CLI_NAME^} ${COMMAND^}"
echo "-------------------------------------------"
echo ""
instantOs
echo ""
case ${COMMAND} in
ls)
  echo -e "\nList"
  echo -e "  * tower"
  ;;
monitoring)
  # to see the log as it happens in a tail fashion
  sudo journalctl -u "$APP" -f
  ;;
log)
  # to browser the log in reverse order
  sudo journalctl -u "$APP" -r
  ;;
journal)
  if [[ ${#OPTIONS[*]} -eq 0 ]]; then
    sudo journalctl -u "$APP"
  else
    sudo journalctl -u "$APP" "${OPTIONS[@]/#/-}"
  fi
  ;;
status)
  sudo systemctl status "$APP"
  ;;
start)
  sudo systemctl start "$APP"
  ;;
reload)
  sudo systemctl reload "$APP"
  ;;
restart)
  sudo systemctl restart "$APP"
  ;;
help)
  print_usage
  ;;
*)
  echo_err "The command $COMMAND is unknown"
  print_usage
  exit 1
  ;;
esac
