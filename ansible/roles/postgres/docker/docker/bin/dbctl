#!/bin/bash

# Ensures that the pipeline returns the exit status of the last command to fail
set -o pipefail
# Exit the script if any error
set -e

# When developing
# docker cp docker/bin/dbctl postgres:/usr/local/bin/

CLI_NAME=$(basename "$0") # Name of the cli
if [[ -z ${DATA_HOME} ]]; then
  echo_err "The DATA_HOME env is mandatory"
fi

CLI_HOME=${DATA_HOME}/${CLI_NAME}
CLI_LOG_FILE=${CLI_HOME}/${CLI_NAME}.log
[ ! -f "$CLI_LOG_FILE" ] && mkdir -p "$CLI_HOME"; touch "$CLI_LOG_FILE"

function finish() {
  printf "\n%s has finished\n" "${CLI_NAME}"
}
trap finish EXIT

# Print the error message $1
function echo_err() {
  RED='\033[0;31m'
  NC='\033[0m' # No Color
  #(>&2 echo -e "${RED}$1${NC}")
  echo_log "${RED}$1${NC}"
}

# Send the message to the log file and the stdout
function echo_log() {

  MESSAGE=$1
  echo -e "$MESSAGE" 2>&1 | tee -a "${CLI_LOG_FILE}"

}

function print_usage() {

  echo ""
  echo "Usage of the cli ${CLI_NAME} against the database (${CTL_DATABASE_NAME})"
  echo ""
  echo "   ${CLI_NAME} command [--option[=value] ...]"
  echo ""
  echo "where command is one of:"
  echo "     * help"
  echo "     * dump-db-backup                            - perform a database dump and a snapshot"
  echo "     * dump-db-restore snapshotId [targetDbName] - restore the database from a snapshot id eventually to another database"
  echo "     * dump-sc-backup [schemaName]               - perform a schema dump and a snapshot"
  echo "     * dump-sc-restore snapshotId [schemaName]   - restore a schema dump from a snapshot id"
  echo "     * dump-ls                                   - list the dump in the snapshots"
  echo "     * db-ls                                     - list the db in the cluster"
  echo "     * dump-prune                                - forget old snapshots and perform dump integrity checks"
  echo "     * extension-ls                              - list the extensions"
  echo "     * conf                                      - print the conf file"
  echo "     * job-ls                                    - print the jobs"
  echo ""

}


declare -a OPTIONS
declare -a ARGS
# Parsing
for arg in "$@"; do
  case "$arg" in
  --*)
    OPTIONS+=("$arg")
    shift
    ;;
  *)
    # Command
    if [ -z "$COMMAND" ]; then
      COMMAND="$arg"
      echo "Command ($COMMAND) found"
    else
      echo "Arg ($arg) found"
      ARGS+=("$arg")
    fi
    shift
    ;;
  esac
done

if [ -z "$COMMAND" ]; then
  echo 'No command was given, help chosen.'
  COMMAND='help'
fi

## Global Parameters
CTL_DATABASE_NAME=${PGDATABASE}
if [ -z "${CTL_DATABASE_NAME}" ]; then
  CTL_DATABASE_NAME=${PGUSER}
fi;
if [ -z "${CTL_DATABASE_NAME}" ]; then
  echo_err "The database could not be determined via PGDATABASE or PGUSER"
  exit 1;
fi;

## Dump parameter
if [[ -z ${PG_DUMP_DATA} ]]; then
    echo_err "The PG_DUMP_DATA var is unknown"
    exit 1;
fi;
mkdir -p "$PG_DUMP_DATA"
DB_DUMP_FILE="$PG_DUMP_DATA"/dumpfile-db-"${CTL_DATABASE_NAME}".sql.gz

echo
echo "${CLI_NAME^} ${COMMAND^}"
echo "-------------------------------------------"
echo ""
case ${COMMAND} in
dump-db-backup)
  echo_log "Dumping the database (${CTL_DATABASE_NAME})"
  pg_dump "${CTL_DATABASE_NAME}" | gzip  > "${DB_DUMP_FILE}"
  echo_log "Done"
  echo_log "Loading into Restic S3 repo (${PG_DUMP_DATA})"
  restic backup "${PG_DUMP_DATA}"
  echo_log "Restic upload done"
  echo_log "Backup done"
  ;;
dump-sc-backup)
  targetSchemaName=${ARGS[0]}
  if [ -z "${targetSchemaName}" ]; then
      targetSchemaName=$DEFAULT_SCHEMA_NAME
  fi
  if [ -z "${targetSchemaName}" ]; then
    echo_err 'No schema defined as first argument and no DEFAULT_SCHEMA_NAME env found'
    echo_err 'A schema is mandatory for a schema dump'
    exit 1
  fi
  echo_log "Dumping the schema (${targetSchemaName}) from the database (${CTL_DATABASE_NAME})"
  SC_DUMP_FILE="$PG_DUMP_DATA"/dumpfile-sc-"${targetSchemaName}".sql.gz
  pg_dump --schema="$targetSchemaName" "${CTL_DATABASE_NAME}" | gzip  > "${SC_DUMP_FILE}"
  echo_log "Done"
  echo_log "Loading into Restic S3 repo (${SC_DUMP_FILE})"
  restic backup "${PG_DUMP_DATA}"
  echo_log "Restic upload done"
  echo_log "Backup done"
  ;;
dump-ls)
  restic find --long  "${PG_DUMP_DATA}"
  ;;
dump-db-restore)
  if [ -z "${ARGS[0]}" ]; then
    echo_err 'The Snapshot Id should be given as first argument'
    echo_err 'use the dump-ls command to get the available snapshot id'
    exit 1
  fi
  snapshot=${ARGS[0]}
  targetDbName=${ARGS[1]}
  if [ -z "${targetDbName}" ]; then
      targetDbName=$CTL_DATABASE_NAME
  fi
  echo_log "Restoring the dump (${DB_DUMP_FILE}) from the snapshot ${snapshot} into the database (${targetDbName})"
  RESTORE_DIR_BASE=/tmp
  restic restore --include "${DB_DUMP_FILE}" --target $RESTORE_DIR_BASE --verify "${snapshot}"
  echo_log "Restoration done"
  dumpFileToRestore="${RESTORE_DIR_BASE}${DB_DUMP_FILE}"
  echo_log "Restoring the database ${targetDbName} with the dump (${dumpFileToRestore}) into the database (${targetDbName})"
  RESULT=$(psql -tAc "SELECT 1 FROM pg_database WHERE datname='${targetDbName}'")
  if [ "$RESULT" == "1" ]; then
    echo_log "The database ${targetDbName} exits and should be dropped before restoration"
    echo_log "Dropping the database ${targetDbName} before restoration"
    dropdb "${targetDbName}" --force -i || exit 1
    echo_log "Done"
  fi;
  echo_log "Creating the database ${targetDbName}"
  createdb "${targetDbName}" || exit 1
  echo_log "Done"
  echo_log "Executing the Sql dump"
  gunzip < "${dumpFileToRestore}" | psql --set ON_ERROR_STOP=on --single-transaction "${targetDbName}"
  echo_log "Done"
  echo_log "Restoration done and successful"
  ;;
dump-prune)
  restic forget --keep-hourly 5 --keep-daily 7 --keep-weekly 5 --keep-monthly 12 --keep-yearly 3;
  restic prune;
  restic check --read-data;
  ;;
db-ls)
  psql -c "\l"
  ;;
extension-ls)
  psql -c "\dx"
  ;;
conf)
  cat /etc/postgresql/postgresql.conf
  ;;
pg)
  pg_ctl "${OPTIONS[@]}"
  ;;
psql)
  psql "${OPTIONS[@]}"
  ;;
job-ls)
  psql -c "select * from cron.job_run_details order by start_time desc limit 5"
  ;;
help)
  print_usage
  ;;
*)
  echo_err "The command $COMMAND is unknown"
  print_usage
  exit 1
  ;;
esac
