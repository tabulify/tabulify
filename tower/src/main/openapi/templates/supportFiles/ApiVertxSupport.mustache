package {{invokerPackage}};

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.http.HttpHeaders;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.handler.HttpException;
import io.vertx.ext.web.openapi.RouterBuilder;
import net.bytle.vertx.TowerFailureTypeEnum;
import net.bytle.vertx.TowerApp;
import java.util.function.Function;

{{#apiInfo}}{{#apis}}
import {{apiPackage}}.{{classname}}Handler;{{#apiNameSuffix}}{{{.}}}{{/apiNameSuffix}}.implementer.{{classname}}Impl;
{{/apis}}{{/apiInfo}}

/**
* This file is generated by the openApi generator
* via the template `ApiMount.mustache`
* Modify the template if needed
* If you want to modify the package, modify also the
* config file: `.openapi-generator-xxxx-config.yaml`
*/
public class ApiVertxSupport {



  public static void mount(RouterBuilder builder, TowerApp towerApp) {
    // we pass the app so that the implementation can use the services attached to the server and http server (jwt, ..)
{{#apiInfo}}{{#apis}}
    new {{classname}}Handler(new {{classname}}Impl(towerApp)).mount(builder);{{/apis}}{{/apiInfo}}

  }

  /**
  * See {@link io.vertx.ext.web.Route#respond(Function)}
  */
  public static void respond(RoutingContext ctx, ApiResponse<?> apiResponse) {

    /**
    * Future.succeededFuture() does not trigger a type error
    */
    if (apiResponse == null) {
      apiResponse = new ApiResponse<>();
    }

    Object data = apiResponse.getData();
    if (ctx.response().headWritten()) {
      if (data == null) {
        if (!ctx.response().ended()) {
          ctx.end();
        }
        return;
      }
      ctx.fail(new HttpException(500, "Response already written"));
    }

    if (data == null) {
      int statusCode = apiResponse.getStatusCode();
      if (statusCode == 200) {
        statusCode = 204;  // No Content success status response
      }
      ctx.response()
         .setStatusCode(statusCode)
         .end();
      return;
    }

    final boolean hasContentType = ctx.response().headers().contains(HttpHeaders.CONTENT_TYPE);
    if (data instanceof Buffer) {
      if (!hasContentType) {
        ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, "application/octet-stream");
      }
      ctx.end((Buffer) data);
      return;
    }

    if (data instanceof String) {
      if (!hasContentType) {
        ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, "text/html");
      }
      ctx.end((String) data);
      return;
    }

    /**
    * Json
    */
    ObjectMapper jsonMapper = apiResponse.getJsonMapper();
    if (jsonMapper != null) {
      ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, "application/json");
      try {
        ctx.response().end(jsonMapper.writeValueAsString(data));
      } catch (JsonProcessingException e) {
        ctx.fail(new HttpException(TowerFailureTypeEnum.INTERNAL_ERROR_500.getStatusCode(), "Unable to map the data to json", e));
      }
      return;
    }
    ctx.json(data);

  }

}
