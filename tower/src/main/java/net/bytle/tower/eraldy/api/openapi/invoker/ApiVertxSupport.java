package net.bytle.tower.eraldy.api.openapi.invoker;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.http.HttpHeaders;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.handler.HttpException;
import io.vertx.ext.web.openapi.RouterBuilder;
import net.bytle.tower.eraldy.api.implementer.*;
import net.bytle.tower.eraldy.api.openapi.interfaces.*;
import net.bytle.vertx.TowerApp;
import net.bytle.vertx.TowerFailureStatusEnum;

import java.util.function.Function;


/**
* This file is generated by the openApi generator
* via the template `ApiMount.mustache`
* Modify the template if needed
* If you want to modify the package, modify also the
* config file: `.openapi-generator-xxxx-config.yaml`
*/
public class ApiVertxSupport {



  public static void mount(RouterBuilder builder, TowerApp towerApp) {
    // we pass the app so that the implementation can use the services attached to the server and http server (jwt, ..)

    new AnalyticsApiHandler(new AnalyticsApiImpl(towerApp)).mount(builder);
    new AppApiHandler(new AppApiImpl(towerApp)).mount(builder);
    new AuthApiHandler(new AuthApiImpl(towerApp)).mount(builder);
    new CampaignApiHandler(new CampaignApiImpl(towerApp)).mount(builder);
    new CspApiHandler(new CspApiImpl(towerApp)).mount(builder);
    new EmailApiHandler(new EmailApiImpl(towerApp)).mount(builder);
    new EnvApiHandler(new EnvApiImpl(towerApp)).mount(builder);
    new HealthApiHandler(new HealthApiImpl(towerApp)).mount(builder);
    new ListApiHandler(new ListApiImpl(towerApp)).mount(builder);
    new OrganizationApiHandler(new OrganizationApiImpl(towerApp)).mount(builder);
    new RealmApiHandler(new RealmApiImpl(towerApp)).mount(builder);
    new ServiceApiHandler(new ServiceApiImpl(towerApp)).mount(builder);
    new UserApiHandler(new UserApiImpl(towerApp)).mount(builder);

  }

  /**
  * See {@link io.vertx.ext.web.Route#respond(Function)}
  */
  public static void respond(RoutingContext ctx, ApiResponse<?> apiResponse) {

    /**
    * Future.succeededFuture() does not trigger a type error
    */
    if (apiResponse == null) {
      apiResponse = new ApiResponse<>();
    }

    Object data = apiResponse.getData();
    if (ctx.response().headWritten()) {
      if (data == null) {
        if (!ctx.response().ended()) {
          ctx.end();
        }
        return;
      }
      ctx.fail(new HttpException(500, "Response already written"));
    }

    if (data == null) {
      int statusCode = apiResponse.getStatusCode();
      if (statusCode == 200) {
        statusCode = 204;  // No Content success status response
      }
      ctx.response()
         .setStatusCode(statusCode)
         .end();
      return;
    }

    final boolean hasContentType = ctx.response().headers().contains(HttpHeaders.CONTENT_TYPE);
    if (data instanceof Buffer) {
      if (!hasContentType) {
        ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, "application/octet-stream");
      }
      ctx.end((Buffer) data);
      return;
    }

    if (data instanceof String) {
      if (!hasContentType) {
        ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, "text/html");
      }
      ctx.end((String) data);
      return;
    }

    /**
    * Json
    */
    ObjectMapper jsonMapper = apiResponse.getJsonMapper();
    if (jsonMapper != null) {
      ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, "application/json");
      try {
        ctx.response().end(jsonMapper.writeValueAsString(data));
      } catch (JsonProcessingException e) {
        ctx.fail(new HttpException(TowerFailureStatusEnum.INTERNAL_ERROR_500.getStatusCode(), "Unable to map the data to json", e));
      }
      return;
    }
    ctx.json(data);

  }

}
